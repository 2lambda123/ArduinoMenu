#ifndef RSITE_ARDUINO_MENU_SYSTEM_BASE
  #define RSITE_ARDUINO_MENU_SYSTEM_BASE

  #define DEBUG

  #include <Arduino.h>
  #include <Streaming.h>//https://github.com/scottdky/Streaming
  #include <Assert4a.h> //https://github.com/nettigo/Assert4a
  #include "macros.h"

  namespace Menu {
    //menu structure objects
    class menuOut;
    class navNode;
    class navRoot;
    class prompt;
    template<typename T> class menuField;
    //struct menuNodeShadow;
    class menuNode;
    class menu;
    template<typename T> class menuVariant;
    template<typename T> class toggle;
    template<typename T> class select;
    template<typename T> class choose;

    typedef int8_t idx_t;
    int print_P(Print& s,const char* at);

    enum result {proceed=0,quit};
    enum systemStyles {_noStyle=0,_menuData=1,_canNav=2,_parentDraw=4,_isVariant=8};
    enum styles {noStyle=0,wrapStyle=1};//,dontEnter=2};
    //representing parsed input codes (can be used with switch/case)
    enum navCmds {noCmd,escCmd,enterCmd,upCmd,downCmd,leftCmd,rightCmd};
    //----------------------------------------------------
    //events generated by the menu system
    enum eventMask {
      noEvent=0,//just ignore all stuff
      activateEvent=1,//this item is about to be active (system event)
      enterEvent=1<<1,//entering navigation level (this menu is now active)
      exitEvent=1<<2,//leaving navigation level
      returnEvent=1<<3,//TODO:entering previous level (return)
      focusEvent=1<<4,//element just gained focus
      blurEvent=1<<5,//element about to lose focus
      selFocusEvent=1<<6,//TODO:child just gained focus
      selBlurEvent=1<<7,//TODO:child about to lose focus
      anyEvent=~0
    };
    //events for the idle function
    enum idleEvent {idleStart,idling,idleEnd};

    /*template<vCall vFunc>
    result rFunc(FUNC_PARAMS) {vFunc(FUNC_VALUES);return proceed;}*/

    #define FUNC_PARAMS eventMask event, navNode& nav, prompt &item, Stream &in, menuOut &out
    #define FUNC_VALUES event,nav,item,in,out

    //callback function type
    typedef result (*callback)(FUNC_PARAMS);
    //typedef void (*vCall)(FUNC_PARAMS);

    //template<callback C> result togFn(FUNC_PARAMS) {Serial<<"togFn!!!"<<endl;return C(FUNC_VALUES);}

    //functions to hook as common prompt actions
    result doNothing();//just proceed with menu
    result doExit();//do not enter a menu or exit the current one

    //idle function  type
    typedef result (*idleFunc)(idleEvent);
    result inaction(idleEvent e);

    //menu element associated function (called for all element registered events)
    struct actionRaw {callback hFn;};
    class action {
      public:
    		callback hFn;//the hooked callback function
    		inline action() {}
        inline action(result (*f)()):hFn((callback)f) {}
    		inline action(result (*f)(eventMask)):hFn((callback)f) {}
        inline action(result (*f)(eventMask,navNode&)):hFn((callback)f) {}
        inline action(result (*f)(eventMask,navNode&,prompt&)):hFn((callback)f) {}
        inline action(result (*f)(eventMask,navNode&,prompt&,Stream&)):hFn((callback)f) {}
    		inline action(callback f):hFn(f) {}
    		inline result operator()(FUNC_PARAMS) const {return ((callback)memPtr(hFn))(FUNC_VALUES);}
    };

    extern action noAction;

    //generic callback
    //typedef void (*simpleFunctionCallback)();
    //generic inctivity function, as default menu suspension handler...
    //void inaction();

    //config
    ///////////////////////////////////////////////////////////////////////////
    struct config {
      const char selectedCursor='>';
      const char disabledCursor='-';
      //const char* exitText=exitTextMem;
      const bool invertFieldKeys=false;//invert for encoder
      const bool nav2D=false;//use left|right keys?
      idleFunc idleTask=inaction;
      struct navCode {navCmds cmd;char ch;} navCodes[7]={
        {noCmd,-1},
        {escCmd,'/'},
        {enterCmd,'*'},
        {upCmd,'+'},
        {downCmd,'-'},
        {leftCmd,'-'},
        {rightCmd,'+'}
      };
      inline char getCmdChar(navCmds cmd) const {return navCodes[cmd].ch;}
    };

    // TODO: make this a parametrized thing instead of a global reference
    extern config options;

    //printing
    /*template<class T> inline menuOut &operator<<(menuOut &o, const T arg) {
      ((Print&)o)<<arg;
      return o;
    }*/
    //template<class T> inline menuOut &operator <<(menuOut &o, T arg);
    Print& operator<<(Print& o,bool b);
    Print& operator<<(Print& o,navCmds cmd);
    Print& operator<<(Print& o,result cmd);
    Print& operator<<(Print& o,eventMask e);
    Print& operator<<(Print& o,prompt const &p);

  }

#endif
