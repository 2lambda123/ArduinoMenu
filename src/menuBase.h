/********************
Sept. 2016 Rui Azevedo - ruihfazevedo(@rrob@)gmail.com
creative commons license 3.0: Attribution-ShareAlike CC BY-SA
This software is furnished "as is", without technical support, and with no
warranty, express or implied, as to its usefulness for any purpose.

Thread Safe: No
Extensible: Yes

base for menu library
definitions and enumerations

www.r-site.net
***/

#ifndef RSITE_ARDUINO_MENU_SYSTEM_BASE
  #define RSITE_ARDUINO_MENU_SYSTEM_BASE

  #define DEBUG

  #include <Arduino.h>
  #include <Streaming.h>//https://github.com/scottdky/Streaming
  #include <Assert4a.h> //https://github.com/nettigo/Assert4a
  #include "macros.h"

  namespace Menu {
    //menu structure objects
    class menuOut;
    class navNode;
    class navRoot;
    class prompt;
    template<typename T> class menuField;
    //struct menuNodeShadow;
    class menuNode;
    class menu;
    template<typename T> class menuVariant;
    template<typename T> class toggle;
    template<typename T> class select;
    template<typename T> class choose;

    typedef int8_t idx_t;
    int print_P(Print& s,const char* at);

    enum result {proceed=0,quit};
    enum systemStyles {_noStyle=0,_menuData=1,_canNav=2,_parentDraw=4,_isVariant=8};
    enum styles {noStyle=0,wrapStyle=1};//,dontEnter=2};
    //representing parsed input codes (can be used with switch/case)
    enum navCmds {noCmd,escCmd,enterCmd,upCmd,downCmd,leftCmd,rightCmd};
    //----------------------------------------------------
    //events generated by the menu system
    enum eventMask {
      noEvent=0,//just ignore all stuff
      activateEvent=1,//this item is about to be active (system event)
      enterEvent=1<<1,//entering navigation level (this menu is now active)
      exitEvent=1<<2,//leaving navigation level
      returnEvent=1<<3,//TODO:entering previous level (return)
      focusEvent=1<<4,//element just gained focus
      blurEvent=1<<5,//element about to lose focus
      selFocusEvent=1<<6,//TODO:child just gained focus
      selBlurEvent=1<<7,//TODO:child about to lose focus
      anyEvent=~0
    };
    //events for the idle function
    enum idleEvent {idleStart,idling,idleEnd};

    enum colorDefs {
      optionColor,
      optionColorHi,
      menuColor,
      menuColorHi,
      fieldColor,
      fieldColorHi,
      valueColor,
      valueColorHi,
      unitColor,
      unitColorHi,
      cursorColor
    };
    enum status {disabledStatus,enabledStatus};
    enum colorPair {background,foreground};

    template<typename T> struct colorPairs {T bg;T fb;};
    template<typename T> struct colorDef {colorPairs<T> pair[2];};
    template<typename T> struct colorTable {colorDef<T> colorDefs[11];};

    //example of color table
    // each color is in the format {{disabled bg,disabled fg},{enabled bg,enabled fg}}
    /*const int colors[][2][2] MEMMODE={
      {{0,1},{0,1}},//option color
      {{0,1},{0,1}},//selected option color
      {{0,1},{0,1}},//menu color
      {{0,1},{0,1}},//selected menu color
      {{0,1},{0,1}},//fieldColor
      {{0,1},{0,1}},//fieldColorHi
      {{0,1},{0,1}},//valueColor
      {{0,1},{0,1}},//valueColorHi
      {{0,1},{0,1}},//unitColor
      {{0,1},{0,1}},//unitColorHi
      {{0,1},{0,1}}//cursorColor
    };*/

    #define FUNC_PARAMS eventMask event, navNode& nav, prompt &item
    #define FUNC_VALUES event,nav,item

    //callback function type
    typedef result (*callback)(FUNC_PARAMS);
    typedef void (*vCall)(FUNC_PARAMS);//now also accept void return

    //functions to hook as common prompt actions
    result doNothing();//just proceed with menu
    result doExit();//do not enter a menu or exit the current one

    //idle function  type
    typedef result (*idleFunc)(idleEvent);
    result inaction(idleEvent e);

    //template<void (*A)(eventMask event, navNode& nav, prompt &item, Stream &in)> result callCaster(eventMask event, navNode& nav, prompt &item, Stream &in);
    template<void (*A)(eventMask event, navNode& nav, prompt &item)> result callCaster(eventMask event, navNode& nav, prompt &item);
    template<void (*A)(eventMask event, navNode& nav)> result callCaster(eventMask event, navNode& nav);
    template<void (*A)(eventMask event)> result callCaster(eventMask event);
    template<void (*A)()> result callCaster();

    //menu element associated function (called for all element registered events)
    struct actionRaw {callback hFn;};
    class action {
      public:
    		callback hFn;//the hooked callback function
    		inline action() {}
        //inline action(void (*f)()):hFn((callback)f) {}
        inline action(result (*f)()):hFn((callback)f) {}
    		inline action(result (*f)(eventMask)):hFn((callback)f) {}
        inline action(result (*f)(eventMask,navNode&)):hFn((callback)f) {}
        //inline action(result (*f)(eventMask,navNode&,prompt&)):hFn((callback)f) {}
        //inline action(result (*f)(eventMask,navNode&,prompt&,Stream&)):hFn((callback)f) {}
    		inline action(callback f):hFn(f) {}
    		inline result operator()(FUNC_PARAMS) const {return ((callback)memPtr(hFn))(FUNC_VALUES);}
    };

    extern action noAction;

    //config
    ///////////////////////////////////////////////////////////////////////////
    struct config {
      const char selectedCursor='>';
      const char disabledCursor='-';
      //const char* exitText=exitTextMem;
      const bool invertFieldKeys=false;//invert for encoder
      const bool nav2D=false;//use left|right keys?
      idleFunc idleTask=inaction;
      struct navCode {navCmds cmd;char ch;} navCodes[7]={
        {noCmd,-1},
        {escCmd,'/'},
        {enterCmd,'*'},
        {upCmd,'+'},
        {downCmd,'-'},
        {leftCmd,'-'},
        {rightCmd,'+'}
      };
      inline char getCmdChar(navCmds cmd) const {return navCodes[cmd].ch;}
    };

    // TODO: make this a parametrized thing instead of a global reference
    extern config options;

    Print& operator<<(Print& o,bool b);
    Print& operator<<(Print& o,navCmds cmd);
    Print& operator<<(Print& o,result cmd);
    Print& operator<<(Print& o,eventMask e);
    Print& operator<<(Print& o,prompt const &p);

  }

#endif
