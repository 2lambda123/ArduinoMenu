<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ArduinoMenu 5: ArduinoMenu 5</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ArduinoMenu 5
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">ArduinoMenu 5 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Generic menu/interactivity system for the arduino framework</b></p>
<h2>Development discussion about next menu version</h2>
<p>This is an experimental area, please contribute with ideas, experience or code. Thank you.</p>
<h3>Why a new version</h3>
<p>In a word, <b>size</b>.</p>
<p>Things I wish were available:</p><ul>
<li>C++14 or +</li>
<li>AVR stl</li>
</ul>
<h2>Current state</h2>
<p><em>tiny.ino</em> example is using a single option print-out chain</p>
<p>with composing menu items, role description tags and role tag catch on output format</p>
<p>output is also a composition, we can compose role tag format handlers and translations.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">// Rui Azevedo - Apr2019</div><div class="line">// neu-rah (ruihfazevedo@gmail.com)</div><div class="line">// LCD example with flash data (Arduino framework)</div><div class="line">//</div><div class="line">// ArduinoMenu libtary 5.x code example</div><div class="line">// Output: LCD</div><div class="line">// flash data</div><div class="line">// Input: user serial driver</div><div class="line"></div><div class="line">#include &lt;menu/def/tinyArduino.h&gt;</div><div class="line">#include &lt;menu/IO/lcdOut.h&gt;</div><div class="line"></div><div class="line">using namespace Menu;</div><div class="line"></div><div class="line">// LCD /////////////////////////////////////////</div><div class="line">#define RS 2</div><div class="line">#define RW 4</div><div class="line">#define EN A4</div><div class="line">LiquidCrystal lcd(RS, RW, EN, A0, A1, A2, A3);</div><div class="line"></div><div class="line">//menu output ------------------------</div><div class="line">MenuOut&lt;AM5::LCDFmt&lt;&gt;::To&lt;LCDOutDev&lt;lcd&gt;&gt;&gt; menuOut;</div><div class="line"></div><div class="line">using Op=Prompt&lt;FlashText&gt;;</div><div class="line"></div><div class="line">const char op1_text[] PROGMEM=&quot;Op 1&quot;;</div><div class="line">Op op1(op1_text);</div><div class="line"></div><div class="line">const char op2_text[] PROGMEM=&quot;Op 2&quot;;</div><div class="line">Op op2(op2_text);</div><div class="line"></div><div class="line">const char op3_text[] PROGMEM=&quot;Op 3&quot;;</div><div class="line">Op op3(op3_text);</div><div class="line"></div><div class="line">const char op4_text[] PROGMEM=&quot;Op 4&quot;;</div><div class="line">Op op4(op4_text);</div><div class="line"></div><div class="line">const char op5_text[] PROGMEM=&quot;Op 5&quot;;</div><div class="line">Op op5(op5_text);</div><div class="line"></div><div class="line">// Prompt&lt;StaticMenu&lt;5&gt;&gt; mainMenu(&quot;Main menu&quot;,&amp;op1,&amp;op2,&amp;op3,&amp;op4,&amp;op5);</div><div class="line">const char menuTitle_text[] PROGMEM=&quot;Main menu&quot;;</div><div class="line">Op menuTitle(menuTitle_text);</div><div class="line">constexpr AM5::FlashData data[5] {&amp;op1,&amp;op2,&amp;op3,&amp;op4,&amp;op5};</div><div class="line">Prompt&lt;AM5::FlashMenuDef&lt;data,5,FlashText&gt;&gt; mainMenu(menuTitle_text);</div><div class="line"></div><div class="line">void setup() {</div><div class="line">  Serial.begin(115200);</div><div class="line">  while(!Serial);</div><div class="line">  lcd.begin(16,2);</div><div class="line">  menuOut&lt;&lt;F(&quot;AM5 example ----&quot;)&lt;&lt;endl;</div><div class="line">  menuOut&lt;&lt;F(&quot;&lt;www.r-site.net&gt;&quot;)&lt;&lt;endl;</div><div class="line">  delay(1500);</div><div class="line">  lcd.clear();</div><div class="line">  menuOut.setTarget(mainMenu);</div><div class="line">  menuOut.printMenu();</div><div class="line">}</div><div class="line"></div><div class="line">//handle serial keys to navigate menu</div><div class="line">bool keys(int key) {</div><div class="line">  switch(key) {</div><div class="line">    case &#39;+&#39;: return menuOut.up();;</div><div class="line">    case &#39;-&#39;: return menuOut.down();;</div><div class="line">    case &#39;*&#39;: return menuOut.enter();;</div><div class="line">    case &#39;/&#39;: return menuOut.esc();;</div><div class="line">  }</div><div class="line">  return false;</div><div class="line">}</div><div class="line"></div><div class="line">void loop() {</div><div class="line">  if (Serial.available()) {</div><div class="line">    if (keys(Serial.read())) menuOut.printMenu();</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><b>footprint:</b> </p><div class="fragment"><div class="line">current:</div><div class="line">ATA:    [==        ]  18.3% (used 374 bytes from 2048 bytes)</div><div class="line">PROGRAM: [==        ]  15.3% (used 4704 bytes from 30720 bytes)</div><div class="line"></div><div class="line">previous:</div><div class="line">DATA:    [==        ]  19.1% (used 392 bytes from 2048 bytes)</div><div class="line">PROGRAM: [==        ]  17.1% (used 5242 bytes from 30720 bytes)</div></div><!-- fragment --><p><em>tinyArduino.h</em> defines <code><a class="el" href="structSerialOut.html">SerialOut</a></code>, <code>Op</code> and <code>FlashOp</code> as: </p><div class="fragment"><div class="line">{c++}</div><div class="line">#include &lt;streamFlow.h&gt;//https://github.com/neu-rah/streamFlow</div><div class="line">#include &quot;../../menu.h&quot;</div><div class="line">#include &quot;../printers.h&quot;</div><div class="line">#include &quot;../comp/flashText.h&quot;</div><div class="line">#include &quot;../comp/flashMenu.h&quot;</div><div class="line"></div><div class="line">namespace Menu {</div><div class="line"></div><div class="line">  using namespace Menu;</div><div class="line"></div><div class="line">  template&lt;typename O&gt;</div><div class="line">  using MenuOut=AM5::MenuOutCap&lt;O&gt;;</div><div class="line"></div><div class="line">  using FlashText=AM5::FlashTextDef&lt;AM5::Empty&gt;;</div><div class="line"></div><div class="line">  using Text=AM5::Text&lt;AM5::Empty&gt;;</div><div class="line"></div><div class="line">  using Item=AM5::Item;</div><div class="line"></div><div class="line">  template&lt;typename O&gt;</div><div class="line">  using Prompt=AM5::Prompt&lt;O&gt;;</div><div class="line"></div><div class="line">  template&lt;size_t n&gt;</div><div class="line">  using StaticMenu=AM5::StaticMenu&lt;n,Text&gt;;</div><div class="line"></div><div class="line">  template&lt;size_t n&gt;</div><div class="line">  using FlashMenu=AM5::StaticMenu&lt;n,FlashText&gt;;</div><div class="line">};</div></div><!-- fragment --><p><a href="https://gitter.im/ArduinoMenu/Lobby">https://gitter.im/ArduinoMenu/Lobby</a></p>
<h3>Embedded systems</h3>
<p>The AM4 approach to library development is not sufficient for embedded systems, modularity by includes is not enough as a means of optimization. As we start adding features soon the menu becomes tight on small devices. So we need to seek modularity even further.</p>
<p>After some research and experimentation here are some considerations about various aspects of menu systems with focus on embedding.</p>
<p>This can also be achieved with C style defines and code exclusion, both approaches are hard. Hopefully this one can be more succinct.</p>
<h3>Is it possible?</h3>
<p>You might be using a single line display, therefore printing a menu title is useless and inconvenient. instead of having a run-time config and code checking if title enabled and skipping title prints on single line devices even if active make a menu system easy to use but also makes it heavier. Examples like this are behind all assumptions we make about a menu system. So instead of having extra runtime check/config we opt instead on having compile-time compositions, think it like, if you want the title on your menus you can simply include that part on the construct. Shifting the burden to compile time reduces the run-time checking, code size and increases speed.</p>
<p><em><b>technical:</b> using type to guide the composition decision, not used code vanish at compile time.</em></p>
<h4>Mixed content</h4>
<p>Instead of setting a menu structure to reside on flash or on ram we can use them mixed. And this is working.</p>
<h4>No assumptions</h4>
<p>Assumptions reveal most of the time, a trade or a burden, assuming that all prompts/options will have a text might not be correct, useful or sufficient, some systems might need multiple texts for multi-language. Same goes to all assumptions about menus, even associated actions.</p>
<h4>Composition (type level)</h4>
<p>The key to obtain better modularity is by code composition using C++ mixins.</p>
<p>We make type level compositions that define a menu system type. That can be adequate for simple or complex system.</p>
<h5>How things compose</h5>
<p>Composition is done at type level using templates and open derivation chain, this is quite loose but this level is not intended for the final user, still it allow a great customization.</p>
<p>It would be useless if we could not escape the type level. We want this different options of different type to co-exist on the same list. Therefor the interface usage. It defines a base menu item and its behavior.</p>
<p>Even not being enforced by C++ we adopted an interface description with a middle composing stage comprised of multiple classes/functionalities with inline static members, this kind of members tend to vanish if not used.</p>
<p>The composed types then are used to construct a specific version for the interface, virtual functions will ensure that the correct type is used covering the composition as a monolith type.</p>
<p>Some compositions are weight-less and therefor should be included always. That is the case of role description tags, all members should have one, they are transparent and no trace of them would be left, but they can influenciate the code generated for certain print devices or output formats if they, the format or device, choose to do so.</p>
<p><b>generic pattern</b></p>
<p>Adapt(Interface)&lt;Comp1&lt;Comp2&lt;Comp3&lt;Terminal&gt;&gt;&gt;&gt;</p>
<p>```c++ //define common functionalities struct Interface { //some virtual functions here };</p>
<p>//make static composition adhere to the interface (as a top level cap) template&lt;typename O&gt; struct Adapt:public Interface,public O { //redirect virtual call to the correct type (because we know it) };</p>
<p>// composition parts -------------------&mdash;</p>
<p>//this is the minimal composition part and acts as an interface for the composing parts // however nothing requires you to derive from it as the members are <code>inline static</code> // consider it just a guide, deriving from it is a discipline struct <a class="el" href="structEmpty.html">Empty</a> { //add base functionality to derived items, not enforced but handy };</p>
<p>template&lt;typename o="Empty"&gt; class Text:public O { protected: const char* text; public: Text(const char* t):text(t) {} //... add specific implementations };</p>
<p>//composing thing for user using Op=Prompt&lt;Text&gt;; //using Op=Prompt&lt;FlashText&gt;;//with this def we can put all Op's into flash (because they share constructor parameter format)</p>
<p>Op op1("Op 1");//now we can simply build an option like this</p>
<div class="fragment"><div class="line">we can implement other building blocks _a la carte_  </div><div class="line">they contain the functionality and its code is vacuous if not used</div><div class="line"></div><div class="line">we might add some sugar on top of this construction methods and build more elaborated blocks for each system.</div><div class="line"></div><div class="line">**extending**</div><div class="line"></div><div class="line">on a separate file, meaning the library can be extended without changing library files</div><div class="line"></div><div class="line">```c++</div><div class="line">  template&lt;typename O&gt;</div><div class="line">  class FlashTextDef:public O {</div><div class="line">  protected:</div><div class="line">    const char *text PROGMEM;</div><div class="line">  public:</div><div class="line">    FlashTextDef(PGM_P t):text(t) {}</div><div class="line">    template&lt;typename Out&gt;</div><div class="line">    inline size_t out(Out&amp; o) {</div><div class="line">      o.raw(reinterpret_cast&lt;const __FlashStringHelper *&gt;(text));</div><div class="line">      return O::out(o);//chain the call</div><div class="line">    }</div><div class="line">  };</div></div><!-- fragment --><h3>Lessons learned</h3>
<p>From previous version we have been adding functionalities and adapting the system design, however always over the same assumptions... Instead keep everything functional and interface contained.</p>
<p>Input manipulation should be independent, the system should only respond to navigation commands.</p>
<p>Output should be single device, multiple device should be implemented as a special device.</p>
<p>Finally found a decent initialization schema so that we can drop the macros (maybe keep them for compatibility/porting)</p>
<p>Target framework should not be limited to Arduino (essay on Linux went well)</p>
<p>Keep menu definitions platform agnostic as was on AM4, make them also framework agnostic.</p>
<p>On version 4 we shifted the complexity to a central core, this makes IO drivers easier to implement an is more efficient when using multiple outputs, but makes an extremely heavy core with many if's and considering too many cases, we need to break this down. Type level composition was the way.</p>
<p>Avoid castings, macros and other bad style c++</p>
<p>Work at type level whenever possible </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
